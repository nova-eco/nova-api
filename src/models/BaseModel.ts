import { Database } from './Database';

/**
 * Base model attributes that all models should have
 */
export interface BaseModelAttributes {
  id: string;
  created?: Date;
  modified?: Date;
}

/**
 * Abstract base class for all models
 * Provides basic CRUD operations using direct SQL queries
 */
export abstract class BaseModel<T extends BaseModelAttributes> {
  protected tableName: string;
  protected primaryKey: string;

  /**
   * Constructor for BaseModel
   * @param tableName The name of the database table
   * @param primaryKey The primary key column name (defaults to 'id')
   */
  constructor(tableName: string, primaryKey: string = 'id') {
    this.tableName = tableName;
    this.primaryKey = primaryKey;
  }

  /**
   * Create a new record in the database
   * @param data The data to insert (without id, created, modified)
   * @returns The created record with id, created, and modified timestamps
   *
   * Note: The id field is auto-generated by MariaDB using UUID()
   */
  async create(data: Omit<T, 'id' | 'created' | 'modified'>): Promise<T> {
    // Build the insert query (MariaDB will auto-generate the UUID for id)
    const fields = Object.keys(data);
    const values = Object.values(data);

    const placeholders = fields.map(() => '?').join(', ');
    const fieldsList = fields.join(', ');

    const sql = `INSERT INTO ${this.tableName} (${fieldsList}) VALUES (${placeholders})`;

    await Database.query(sql, values);

    // MariaDB returns the insert result with insertId, but for UUID we need to get the LAST_INSERT_ID or query back
    // Since we're using UUIDs (not auto-increment), we need to retrieve the record differently
    // We'll use a SELECT with the unique data we just inserted

    // Get the ID of the inserted record using LAST_INSERT_ID won't work with UUID
    // Instead, we'll query back using the inserted data
    // For now, let's use a more reliable approach: SELECT the record with matching data

    // Build a WHERE clause with the inserted data
    const whereConditions = fields.map((field) => `${field} = ?`).join(' AND ');
    const selectSql = `SELECT * FROM ${this.tableName} WHERE ${whereConditions} ORDER BY created DESC LIMIT 1`;

    const records = await Database.query<T>(selectSql, values);

    if (records.length === 0) {
      throw new Error(`Failed to create record in ${this.tableName}`);
    }

    return records[0];
  }

  /**
   * Find a record by its primary key
   * @param id The primary key value
   * @returns The record if found, null otherwise
   */
  async findByPk(id: string): Promise<T | null> {
    const sql = `SELECT * FROM ${this.tableName} WHERE ${this.primaryKey} = ? LIMIT 1`;
    const results = await Database.query<T>(sql, [id]);

    return results.length > 0 ? results[0] : null;
  }

  /**
   * Find one record matching the conditions
   * @param where Object with field/value pairs to match
   * @returns The first matching record or null
   */
  async findOne(where: Partial<T>): Promise<T | null> {
    const fields = Object.keys(where);
    const values = Object.values(where);

    if (fields.length === 0) {
      return null;
    }

    const whereClause = fields.map((field) => `${field} = ?`).join(' AND ');
    const sql = `SELECT * FROM ${this.tableName} WHERE ${whereClause} LIMIT 1`;

    const results = await Database.query<T>(sql, values);
    return results.length > 0 ? results[0] : null;
  }

  /**
   * Find all records in the table
   * @param options Optional: { where, limit, offset, orderBy }
   * @returns Array of records
   */
  async findAll(options?: {
    where?: Partial<T>;
    limit?: number;
    offset?: number;
    orderBy?: string;
  }): Promise<T[]> {
    let sql = `SELECT * FROM ${this.tableName}`;
    const params: unknown[] = [];

    // Add WHERE clause if provided
    if (options?.where) {
      const fields = Object.keys(options.where);
      const values = Object.values(options.where);

      if (fields.length > 0) {
        const whereClause = fields.map((field) => `${field} = ?`).join(' AND ');
        sql += ` WHERE ${whereClause}`;
        params.push(...values);
      }
    }

    // Add ORDER BY if provided
    if (options?.orderBy) {
      sql += ` ORDER BY ${options.orderBy}`;
    }

    // Add LIMIT if provided
    if (options?.limit !== undefined) {
      sql += ` LIMIT ?`;
      params.push(options.limit);
    }

    // Add OFFSET if provided
    if (options?.offset !== undefined) {
      sql += ` OFFSET ?`;
      params.push(options.offset);
    }

    return Database.query<T>(sql, params);
  }

  /**
   * Find records by a specific field value
   * @param field The field name to search by
   * @param value The value to search for
   * @returns Array of matching records
   */
  async findBy(field: keyof T, value: unknown): Promise<T[]> {
    const sql = `SELECT * FROM ${this.tableName} WHERE ${String(field)} = ?`;
    return Database.query<T>(sql, [value]);
  }

  /**
   * Update a record by primary key
   * @param id The primary key value
   * @param data The data to update
   * @returns The updated record if found, null otherwise
   */
  async update(
    id: string,
    data: Partial<Omit<T, 'id' | 'created' | 'modified'>>,
  ): Promise<T | null> {
    const fields = Object.keys(data);
    const values = Object.values(data);

    if (fields.length === 0) {
      return this.findByPk(id);
    }

    const setClause = fields.map((field) => `${field} = ?`).join(', ');
    const sql = `UPDATE ${this.tableName} SET ${setClause} WHERE ${this.primaryKey} = ?`;

    values.push(id);

    await Database.query(sql, values);

    return this.findByPk(id);
  }

  /**
   * Count records in the table
   * @param where Optional conditions to filter records
   * @returns The count of matching records
   */
  async count(where?: Partial<T>): Promise<number> {
    let sql = `SELECT COUNT(*) as total FROM ${this.tableName}`;
    const params: unknown[] = [];

    if (where) {
      const fields = Object.keys(where);
      const values = Object.values(where);

      if (fields.length > 0) {
        const whereClause = fields.map((field) => `${field} = ?`).join(' AND ');
        sql += ` WHERE ${whereClause}`;
        params.push(...values);
      }
    }

    const results = await Database.query<{ total: number }>(sql, params);
    return results[0]?.total || 0;
  }

  /**
   * Execute a raw SQL query
   * @param sql The SQL query
   * @param params Optional query parameters
   * @returns Query results
   */
  protected async executeQuery<R = unknown>(
    sql: string,
    params?: unknown[],
  ): Promise<R[]> {
    return Database.query<R>(sql, params);
  }
}
